# Procesamiento


```{r datos_originales2,include=FALSE}
# Importar base de datos
datos <- readxl::read_excel("datos/datos_actividad1.xlsx", sheet = 1)  
```


## Errores e inconsistencias

### Errores de escritura

En la primera etapa del preprocesamiento de los datos, se procedió a la estandarización de la notación utilizada en las categorías de las variables *Sexo*, *Categoría* y *Método de pago*. Estas variables presentaban inconsistencias tipográficas al representar una misma categoría. Por ejemplo, en la variable *Sexo* se encontraron notaciones como `"female"` y `"Female"`, así como `"male"` y `"Male"`, los cuales debían ser tratados como equivalentes. De manera similar, en la variable *Categoría* se identificaron registros como `"clothing"` y `"Clothing"`, `"cosmetics"` y `"Cosmetics"`, así como `"toys"`, `"Toys"` y `"ToyS"`, todos ellos correspondientes a una misma categoría conceptual. En el caso de la variable *Método de pago*, se observaron valores como `"cash"` y `"Cash"`, además de `"debit card"` y `"Debit card"`, que remiten a una misma modalidad de pago. Estas inconsistencias fueron corregidas mediante la transformación a notación estandarizada en minúsculas.

### Inconsistencias

En una segunda etapa, se verificó la unicidad de los identificadores de facturas, considerando que, en términos generales, un número de factura no debería repetirse dentro de un mismo sistema de facturación, dado que su función principal es permitir la identificación única de cada transacción registrada, tanto para fines internos como fiscales. No obstante, es posible que un mismo identificador aparezca en múltiples filas cuando cada una representa un producto distinto incluido en la misma factura. Sin embargo, este no fue el caso en el presente conjunto de datos.

Durante la revisión de los identificadores de factura, se detectaron nueve registros duplicados, en los cuales el mismo número de factura estaba asociado a diferentes fechas y clientes. De estos duplicados, siete coincidían completamente en la información relacionada con el cliente y la transacción realizada, lo que indicó la presencia de duplicados exactos. Como resultado, se eliminaron siete de estos registros, dejando solo uno por factura. Además, se identificaron dos facturas duplicadas debido a errores en la asignación de identificadores, lo que afectó a cuatro registros. A estos registros se les asignaron nuevos identificadores únicos: `"i000000"`, `"i111111"`, `"i222222"` y `"i333333"`. Como consecuencia de este proceso, se eliminaron 7 registros, quedando un total de 99,459 transacciones para continuar con el análisis.



```{r,eval=TRUE,include=FALSE}
# Creación de tablas de variables cualitativas para revisar notación de categorías
table(datos$invoice_no)
pos1<-which(table(datos$invoice_no)!=1)
duplicadas1<-table(datos$invoice_no)[pos1]

table(datos$customer_id)
pos2<-which(table(datos$customer_id)!=1)
duplicadas2<-table(datos$customer_id)[pos2]

table(datos$gender)
table(datos$category)
table(datos$payment_method)
table(datos$shopping_mall)

# Unificación de la notación de categorías y convresión a minúsculas
datos$invoice_no     = str_to_lower(datos$invoice_no)
datos$customer_id    = str_to_lower(datos$customer_id)
datos$gender         = str_to_lower(datos$gender)
datos$category       = str_to_lower(datos$category)
datos$payment_method = str_to_lower(datos$payment_method)
datos$shopping_mall  = str_to_lower(datos$shopping_mall)

# Revisando que haya unico identificador de factura
table(datos$invoice_no)
pos1<-which(table(datos$invoice_no)!=1)
duplicadas1<-table(datos$invoice_no)[pos1]
pos1 # 9 facturas con Id repetido: i131678 i152790 i184085 i258204 i294687 i317333 i337719 i934204 i993048 


# Identificación de registros duplicados 
pos<-which(duplicated(datos)==TRUE)
datos$invoice_no[pos]  
# [1] "i317333" "i294687" "i337719" "i258204" "i152790" "i131678" "i184085"
# Las facturas i934204 i993048 no correspondn a registros duplicados

num_filas_duplicadas_1 <- sum(duplicated(datos))#7 filas duplicadas
print(paste("Registro duplicados:", num_filas_duplicadas_1))


# Eliminación  de registros duplicados
datos_sin_duplicados <- datos %>%
  distinct()

# Identificación de posición en la data de facturas con Id con error
pos3<-which(datos_sin_duplicados$invoice_no=="i934204") 
pos4<-which(datos_sin_duplicados$invoice_no=="i993048")       
      


# Eliminación de registros de facturas mal registradas
datos_sin_duplicados[c(pos3,pos4),1]<-c("i000000","i111111","i222222","i333333")

#Número de registros y variables
dim(datos_sin_duplicados)
datos_mod1<-datos_sin_duplicados
```



```{r fig-edad, eval=TRUE,fig.cap="Edad (años).",echo=FALSE}
ggplot(datos_mod1, aes(y = age)) +
  geom_boxplot() +
  labs(y = "Edad")
```

```{r tabla-edad, eval=TRUE,echo=FALSE}
tabla_edad <- datos_mod1 %>%
  summarise(
    Registros = n(),
    `Mínimo` = min(age, na.rm = TRUE),
    `Cuartil 1` = quantile(age, 0.25, na.rm = TRUE),
    Mediana   = quantile(age, 0.5, na.rm = TRUE),
    `Cuartil 3` = quantile(age, 0.75, na.rm = TRUE),
    `Máximo` = max(age, na.rm = TRUE),
    iqr = IQR(age, na.rm = TRUE),
    `Atípicos menores` = sum(age < ( `Cuartil 1` - 1.5 * iqr), na.rm = TRUE),
    `Atípicos mayores` = sum(age > ( `Cuartil 3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)


# Mostrar la tabla con un caption y label
knitr::kable(tabla_edad, 
             booktabs = TRUE,
             caption = "Estadísticas de Edad (años).") 
```

En una tercera etapa se analizaron posibles errores y valores atípicos en las variables cuantitativas.

La Figura \@ref(fig:fig-edad) evidencia que la variable *Edad* no presenta valores atípicos. Este hallazgo se corrobora con la Tabla \@ref(tab:tabla-edad), la cual muestra las estadísticas descriptivas de la variable Edad y revela que el rango de edades, de 18 a 69 años, es coherente y plausible para los identificadores de compra.



```{r fig-precio-categorias, eval=TRUE,fig.cap="Precio (liras turcas) por Categoría del producto.", echo=FALSE}
ggplot(datos_mod1, aes(x = category, y = price)) +
  geom_boxplot() +
  labs(x = "Categoría", y = "Precio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r tabla-precio-categoria, eval=TRUE,echo=FALSE}
tabla_resumen1 <- datos_mod1 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  summarise(
    Registros = n(),
    `NA en price` = sum(is.na(price)),
     `Mínimo` = min(price, na.rm = TRUE),
    `Cuartil 1` = quantile(price, 0.25, na.rm = TRUE),
    Mediana    = quantile(price, 0.5, na.rm = TRUE),
    `Cuartil 3`  = quantile(price, 0.75, na.rm = TRUE),
    `Máximo` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atípicos menores` = sum(price < (`Cuartil 1` - 1.5 * iqr), na.rm = TRUE),
    `Atípicos mayores` = sum(price > (`Cuartil 3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)



# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen1, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas) por Categoría del producto.") 
```


La Figura \@ref(fig:fig-precio-categorias) indica que, en la variable *Precio*, se detectó al menos un valor atípico en la categoría `books, food and beverage`. La Tabla \@ref(tab:tabla-precio-categoria) presenta las estadísticas de la variable *Precio* para cada categoría de productos. Se observa que en las categorías `books` y `food and beverage` el precio de un producto es significativamente superior al de los demás. Asimismo, se identificó un valor atípico entre los nueve datos faltantes (`NA`).


Los valores atípicos de 7,575,000 y 523,000 liras turcas, correspondientes a las categorías `books` y `food and beverage`, representan precios unitarios muy altos para sus respectivas categorías. Por ello, se consideran valores inconsistentes. Estos tres datos atípicos serán tratados como datos faltantes (`NA`) en el resto del análisis. Posteriormente, se observa en la Figura \@ref(fig:fig-precio-categoria-sin-atipicos) que la variable *Precio* ya no presenta estos valores inconsistentes.


```{r tabla-precio-categoria-sin-atipicos, eval=TRUE,echo=FALSE}
# Columna de índice (posición)
datos_mod2 <- datos_mod1 %>%
  mutate(pos = row_number())

# Calcular los límites y detectar outliers por categoría para crear la tabla
tabla_outliers <- datos_mod2 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  mutate(
    q1 = quantile(price, 0.25, na.rm = TRUE),
    q3 = quantile(price, 0.75, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    lower_lim = q1 - 1.5 * iqr,
    upper_lim = q3 + 1.5 * iqr
  ) %>%
  # Filtrar los registros atípicos
  filter(price < lower_lim | price > upper_lim) %>%
  summarise(
    outlier_positions = list(pos),
    n_atipicos = n()
  )

# Extraer todas las posiciones de los outliers en un vector sencillo
all_outlier_positions <- unlist(tabla_outliers$outlier_positions)

# Reemplazar en el data frame los valores atípicos de 'price' por NA
datos_mod2$price[all_outlier_positions] <- NA
```


```{r fig-precio-categoria-sin-atipicos, eval=TRUE,fig.cap="Precio (liras turcas) por categoría del producto sin atípicos.", echo=FALSE}
ggplot(datos_mod2, aes(x = category, y = price, fill = category)) +
  geom_boxplot() +
  labs(x = "Categoría", y = "Precio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


La Tabla \@ref(tab:tabla-precio-categoria-sin-atipicos2) muestra las estadísticas de la variable *Precio* excluyendo las tres inconsistencias identificadas por valores atípicos. Se ha observado que, en las categorías `clothing` y `technology`, los valores de 1 y 3 liras turcas, respectivamente, no son plausibles en centros comerciales de ropa y tecnología nueva. Por ello, dichos valores han sido clasificados como inconsistentes y, en lo sucesivo, se tratarán como datos faltantes.

Adicionalmente, se ha determinado que el valor de 7,575 liras turcas asignado a la categoría de `books` solo podría corresponder a ediciones de lujo, las cuales no están contempladas en los centros comerciales de la muestra. La Tabla \@ref(tab:tabla-precio-categoria-sin-atipicos-sin-inconsistencias) presenta las estadísticas de la variable *Precio* luego de reemplazar estas inconsistencias por `NA`. Asimismo, se evidencia que el valor de 2 liras turcas para la categoría `clothing` debe ser considerado `NA`. 

La Tabla \@ref(tab:tabla-precio-categoria-sin-atipicos-sin-inconsistencias2) expone las estadísticas del precio por categoría tras el tratamiento de las inconsistencias como datos faltantes. Se ha determinado que los siguientes rangos de precios en liras turcas son plausibles en los diez centros comerciales de la muestra:  

- `books`: entre 303 y 4,545  

- `clothing`: entre 15,004 y 120,032  

- `cosmetics`: entre 2033 y 16,264  

- `food and Beverage`: entre 523 y 2615  

- `shoes`: entre 60,017 y 300,085  

- `souvenir`: entre 1,173 y 5,865  

- `sechnology`: entre 1,050 y 5,250  

- `toys`: entre 1,792 y 14,336




```{r tabla-precio-categoria-sin-atipicos2, eval=TRUE,echo=FALSE}
tabla_resumen2 <- datos_mod2 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  summarise(
    Registros = n(),
    `NA en price` = sum(is.na(price)),
    `Mínimo` = min(price, na.rm = TRUE),
    `Cuartil 1` = quantile(price, 0.25, na.rm = TRUE),
    Mediana    = quantile(price, 0.5, na.rm = TRUE),
    `Cuartil 3`  = quantile(price, 0.75, na.rm = TRUE),
    `Máximo` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atípicos menores` = sum(price < (`Cuartil 1` - 1.5 * iqr), na.rm = TRUE),
    `Atípicos mayores` = sum(price > (`Cuartil 3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)


# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen2, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas) sin 3 atípicos.") 
```


```{r tabla-precio-categoria-sin-atipicos-sin-inconsistencias, eval=TRUE,echo=FALSE}

# Reemplazar valores específicos según la categoría:
datos_mod3 <- datos_mod2 %>%
  filter(!is.na(category)) %>%
  mutate(price = case_when(
    category == "clothing" & price == 1 ~ NA,      # Reemplaza 1 por NA en 'clothing'
    category == "technology" & price == 3 ~ NA,     # Reemplaza 3 por NA en 'technology'
    TRUE ~ price
  ))

tabla_resumen3 <- datos_mod3 %>%
  group_by(category) %>%
  summarise(
    Registros = n(),
    `NA en price` = sum(is.na(price)),
    `Mínimo` = min(price, na.rm = TRUE),
    `Cuartil 1` = quantile(price, 0.25, na.rm = TRUE),
    Mediana    = quantile(price, 0.5, na.rm = TRUE),
    `Cuartil 3`  = quantile(price, 0.75, na.rm = TRUE),
    `Máximo` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atípicos menores` = sum(price < (`Cuartil 1` - 1.5 * iqr), na.rm = TRUE),
    `Atípicos mayores` = sum(price > (`Cuartil 3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)



# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen3, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas) sin  inconsistencias de clothing y technology.") 

```


```{r tabla-precio-categoria-sin-atipicos-sin-inconsistencias2, eval=TRUE,echo=FALSE}
# Reemplazar valores específicos según la categoría:
datos_mod4 <- datos_mod3 %>%
  mutate(price = case_when(
    category == "clothing" & price == 2 ~ NA,      # Reemplaza 1 por NA en 'clothing'
    category == "books" & price == 7575 ~ NA,      # Reemplaza 1 por NA en 'clothing'
    TRUE ~ price
  ))

tabla_resumen4 <- datos_mod4 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
 summarise(
    Registros = n(),
    `NA en price` = sum(is.na(price)),
    `Mínimo` = min(price, na.rm = TRUE),
    `Cuartil 1` = quantile(price, 0.25, na.rm = TRUE),
    Mediana    = quantile(price, 0.5, na.rm = TRUE),
    `Cuartil 3`  = quantile(price, 0.75, na.rm = TRUE),
    `Máximo` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atípicos menores` = sum(price < (`Cuartil 1` - 1.5 * iqr), na.rm = TRUE),
    `Atípicos mayores` = sum(price > (`Cuartil 3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)




# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen4, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas) sin  inconsistencias de clothing y technology.") 

```

Finalmente, la Tabla \@ref(tab:tabla-cantidad-categoria) expone las estadísticas de la cantidad de productos por categoría. Los resultados no muestran inconsistencias que se deben resolver.

```{r tabla-cantidad-categoria, eval=TRUE,echo=FALSE}
tabla_resumen_cantidad <- datos_mod4  %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  summarise(
    Registros = n(),
    `NA en price` = sum(is.na(quantity)),
     `Mínimo` = min(quantity, na.rm = TRUE),
    `Cuartil 1` = quantile(quantity, 0.25, na.rm = TRUE),
    Mediana    = quantile(quantity, 0.5, na.rm = TRUE),
    `Cuartil 3`  = quantile(quantity, 0.75, na.rm = TRUE),
    `Máximo` = max(quantity, na.rm = TRUE),
    iqr = IQR(quantity, na.rm = TRUE),
    `Atípicos menores` = sum(quantity < (`Cuartil 1` - 1.5 * iqr), na.rm = TRUE),
    `Atípicos mayores` = sum(quantity > (`Cuartil 3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)



# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen_cantidad, 
             booktabs = TRUE,
             caption = "Estadísticas de Cantidad de productos.") 
```

---

## Análisis de datos atípicos

lalalalalal


---

## Identificación de datos faltantes

La Figura \@ref(fig:fig-datos-faltantes) muestra que las variables *Precio*, *Sexo* y *Edad* presentan el mayor porcentaje de datos faltantes, seguidas de `shopping_mall` y `payment_method`. Asimismo, evidencia que el porcentaje más alto de datos faltantes no supera el 0.0107.


Adicionalmente, la Figura \@ref(fig:fig-datos-faltantes) indica que el 98.885% de los registros no presenta datos faltantes (combinación 1), mientras que el 1.058% de registros presenta valores faltantes en *Precio* (combinación 2). Además, se identificaron el 0.019% de registros con datos faltantes en *Edad* (combinación 3) y otro 0.019% en *Sexo* (combinación 4). De igual forma, se detectó que el 0.11% de los registros tienen datos faltantes en *Centros comerciales* (combinación 5), el 0.005% en *Método de pago* (combinación 6) y, finalmente, el 0.003% en los que se registró la ausencia tanto en *Método de pago* como en *Precio* (combinación 7). A continuación, se presenta un resumen de las variables ordenadas según el número de datos faltantes.


 
```{r fig-datos-faltantes, eval=TRUE,fig.cap="Porcentaje de datos faltantes por variables y combinaciones de faltantes por variables.", echo=FALSE,fig.width=10, fig.height=8}


datos_mod4<-datos_mod4[,1:10]

par(mar = c(6, 2, 2, 8) + 0.1) # Margen inferior, izquierda, superior y derecha

VIM::aggr(datos_mod4,
          col = c("#DB735C", "#2A91A2"),
          numbers = TRUE,
          sortVars = TRUE,
          labels = names(datos_mod4),
          cex.axis = 0.5,
          gap = 3,
          ylab = c("Proporción de datos", "Datos faltantes"))
```


Para evaluar formalmente si las ausencias se distribuyen de manera completamente aleatoria (MCAR), se aplicó la prueba de Little (implementada en `naniar::mcar_test()`) a las variables cuantitativas (*Edad*, *Cantidad*, *Precio*), cuya hipótesis nula establece que los datos faltantes se distribuyen de forma aleatoria. Dado el gran tamaño de la base de datos (99,450 registros), se estableció un nivel de significancia muy estricto (0.0001).

El $valor-p$ obtenido fue igual a cero, lo que lleva al rechazo de la hipótesis nula con una significancia del 0.1%. Esto indica que existe evidencia suficiente para descartar que los datos faltantes sean completamente aleatorios, sugiriendo que el mecanismo de ausencia probablemente sea MNAR (Missing Not At Random).


```{r test-MCAR, eval=TRUE, echo=FALSE}
# Seleccionar únicamente las variables cuantitativas pertinentes para el test
datos_numeric <- datos_mod4 %>% 
  select(age, quantity, price)

# Aplicar el test de Little para evaluar si los datos faltantes son MCAR
resultado_mcar <- naniar::mcar_test(datos_numeric)

# Extraer el valor p del resultado del test
p_val <- resultado_mcar$p.value

# Imprimir el valor p obtenido
cat("Valor-p =", p_val, "\n")
```


```{r figNormMCAR, eval=TRUE, fig.cap="QQplot y curvas de densidad de variables cuantitativas.", echo=FALSE}

# Crear gráficos Q-Q y de densidad para la variable 'age'
qq_age <- ggplot(datos_numeric, aes(sample = age)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  ggtitle("Q-Q Plot: age")

density_age <- ggplot(datos_numeric, aes(x = age)) +
  geom_density(fill = "blue", alpha = 0.3) +
  ggtitle("Densidad: age")

# Crear gráficos Q-Q y de densidad para la variable 'quantity'
qq_quantity <- ggplot(datos_numeric, aes(sample = quantity)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  ggtitle("Q-Q Plot: quantity")

density_quantity <- ggplot(datos_numeric, aes(x = quantity)) +
  geom_density(fill = "blue", alpha = 0.3) +
  ggtitle("Densidad: quantity")

# Crear gráficos Q-Q y de densidad para la variable 'price'
qq_price <- ggplot(datos_numeric, aes(sample = price)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  ggtitle("Q-Q Plot: price")

density_price <- ggplot(datos_numeric, aes(x = price)) +
  geom_density(fill = "blue", alpha = 0.3) +
  ggtitle("Densidad: price")

# Organizar todos los gráficos en una sola visualización (3 filas x 2 columnas)
grid.arrange(
  qq_age, density_age,
  qq_quantity, density_quantity,
  qq_price, density_price,
  ncol = 2
)
```

Según la Figura \@ref(fig:figNormMCAR), las variables cuantitativas no cumplen el supuesto de la normalidad  debido principalmente a la marcada discrecionalidad de *Cantidad* y a la fuerte asimetría observada en *Precio*. Este incumplimiento de los supuestos necesarios pone en entredicho la fiabilidad del test MCAR (basado en el método de Little), que indicó que los datos no se distribuyen de forma completamente aleatoria.

El objetivo del siguiente análisis es evaluar el mecanismo de ausencia de datos en la variable *Precio*. Para ello, se creó una variable indicadora que refleja si el dato de *Precio* está ausente (1) o presente (0). Posteriormente, se ajustó un modelo de regresión logística utilizando como predictores las variables *Edad*, *Cantidad*, *Sexo* y *Categoría*. 

El modelo permite determinar si la probabilidad de tener un dato faltante en *Precio* está asociada a alguna de estas variables, lo que ayudaría a descartar la hipótesis de que los datos faltantes se distribuyen de forma completamente aleatoria (MCAR).

```{r glmMCAR_Precio, eval=TRUE, echo=FALSE}
datos_mod4 <- datos_mod4 %>%
  mutate(miss_price = ifelse(is.na(price), 1, 0))

modelo_missing <- glm(miss_price ~ age + quantity + factor(gender) + factor(category) + factor(payment_method), 
                      data = datos_mod4, family = binomial)
summary(modelo_missing)
```

De los resultados anteriores se puede decir que el modelo de regresión logística evidencia que existen asociaciones significativas entre la probabilidad de tener datos faltantes en *Precio* y las variables *Cantidad* y *Categoría*. En contraste, *Edad*, *Método de pago* y *Sexo* no resultaron ser predictores de la ausencia de *Precio*. Esto proporciona evidencia para descartar un patrón completamente aleatorio (MCAR). En consecuencia para realizar la imputación se tendrán en cuenta la imputación por grupos de acuerdo con las categorías de las variables anteriores.


```{r glmMCAR_Edad, eval=TRUE, echo=FALSE}
datos_mod4 <- datos_mod4 %>%
  mutate(miss_age = ifelse(is.na(age), 1, 0))

modelo_missing <- glm(miss_age ~ price + quantity + factor(gender) + factor(category) + factor(payment_method), 
                      data = datos_mod4, family = binomial)
summary(modelo_missing)
```

El modelo de regresión logística para la variable *Edad* no muestra ninguna asociación significativa entre la ausencia de *Edad* y las variables *Precio*, *Cantidad*, *Sexo*, *Categoría* o *Método de pago*. Asimismo las Figuras \@ref(fig:figEP) y \@ref(fig:figEM)  no muestran asociación entre *Edad* con *Niveles del precio*, *Precio* y *Método de pago*. Esto implica que, dentro de las variables consideradas, la falta de datos en *Edad* parece ocurrir de manera independiente, lo cual es consistente con un patrón de datos faltantes MCAR para esta variable.



```{r figEP,fig.cap="Distribución de Edad por Niveles del precio B=Bajo, MB=Medio-Bajo, MA=Medio-Alto, A=Alto.", echo=FALSE}

datos_aux <- datos_mod4 %>% filter(!is.na(age) & !is.na(price))

# Edad versus Precio
plot_age<-ggplot(datos_aux, aes(x = age, y = price)) +
  geom_point(color = "#DB735C", alpha = 0.6) +
  labs(title = "Edad vs. Precio",
       x = "Edad",
       y = "Precio") +
  theme_minimal()

# Crear una variable categórica a partir de 'price' usando los cuartiles
datos_mod4_aux<- datos_mod4 %>%
    mutate(price_cat = cut(price,
                           breaks = quantile(price, probs = seq(0, 1, 0.25), na.rm = TRUE),
                           include.lowest = TRUE,
                           labels = c("B", "MB", "MA", "A"))) %>%
    # Filtramos solo registros con valores válidos en age y en la nueva variable de categoría
    filter(!is.na(age) & !is.na(price_cat))

# Boxplot: Edad por categoría de precio
box_age <- ggplot(datos_mod4_aux, aes(x = price_cat, y = age)) +
    geom_boxplot(fill = "#DB735C", alpha = 0.7) +
    labs(title = "Edad por Niveles de Precio", 
         x = "Categoría de Precio", y = "Edad") +
    theme_minimal()

# Curva de densidad: Edad, coloreada por categoría de precio
density_age <- ggplot(datos_mod4_aux, aes(x = age, color = price_cat)) +
  geom_density(linewidth = 1) +
  labs(title = "Edad por N.Precio", 
       x = "Edad", y = "Densidad") +
  theme_minimal() +
  theme(legend.title = element_blank())


# Organizar ambos gráficos en una sola visualización (2 columnas)
grid.arrange(plot_age, box_age, density_age, ncol = 2,nrow=2)
```

```{r figEM,fig.cap="Distribución de edad y cantidad.", echo=FALSE}

# Filtrar datos para asegurar que no existan NA en 'age' ni 'payment_method'
datos_mod4_aux <- datos_mod4 %>%
  filter(!is.na(age) & !is.na(payment_method))

# Boxplot: Edad por Método de Pago
box_age_payment <- ggplot(datos_mod4_aux, aes(x = payment_method, y = age)) +
  geom_boxplot(fill = "#DB735C", alpha = 0.7) +
  labs(title = "Edad por Método de pago", 
       x = "Método de Pago", y = "Edad") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Curva de Densidad: Edad con diferenciación por Método de Pago
density_age_payment <- ggplot(datos_mod4_aux, aes(x = age, fill = payment_method)) +
  geom_density(alpha = 0.5) +
  labs(title = "Edad por Método de pago", 
       x = "Edad", y = "Densidad") +
  theme_minimal() +
  theme(legend.title = element_blank())

# Organizar ambos gráficos en una sola visualización (2 columnas)
grid.arrange(box_age_payment, density_age_payment, ncol = 2)
```



```{r TestChisqMCAR_PMethod, eval=TRUE, echo=FALSE}
# Crear una variable indicadora para missing en payment_method
datos_mod4 <- datos_mod4 %>% 
  mutate(miss_payment = ifelse(is.na(payment_method), 1, 0))

# Tabla de contingencia entre la ausencia en payment_method y category
tabla_contingencia <- table(datos_mod4$miss_payment, datos_mod4$category)
print(tabla_contingencia)

# Prueba de chi-cuadrado
chisq_test <- chisq.test(tabla_contingencia)
print(chisq_test)
```

En la tabla de contingencia anterior que relaciona la presencia y ausencia de datos en *Método de pago* con las distintas categorías, se observa que casi todos los registros se concentran en la fila 0 (datos presentes), mientras que la fila 1 (datos faltantes) muestra recuentos extremadamente bajos. Al aplicar el test de chi-cuadrado, se obtuvo un $valor-p$ de 0.2017, lo que lleva a no rechazar la hipótesis nula de independencia con una significancia del 5%. En otras palabras, no se encontró evidencia estadística suficiente para afirmar que exista una asociación significativa entre la categoría del producto y la presencia de datos faltantes en *Método de pago*.

```{r TestChisqMCAR_PMethod2, eval=TRUE, echo=FALSE}
# Crear una variable indicadora para missing en payment_method
datos_mod4 <- datos_mod4 %>% 
  mutate(miss_payment = ifelse(is.na(payment_method), 1, 0))

# Tabla de contingencia entre la ausencia en payment_method y gender
tabla_contingencia <- table(datos_mod4$miss_payment, datos_mod4$gender)
print(tabla_contingencia)

# Prueba de chi-cuadrado
chisq_test <- chisq.test(tabla_contingencia)
print(chisq_test)
```


En la tabla de contingencia que relaciona la ausencia de *Método de pago* con *Sexo*, se observa que la gran mayoría de los registros tienen datos presentes (fila 0), con 59,461 registros para 'female' y 39,962 para 'male', mientras que en la fila de datos faltantes (fila 1) apenas hay 6 registros para 'female' y 2 para 'male'.

Al aplicar el test de chi-cuadrado, se obtuvo un $valor-p$ de 0.6059. Este resultado indica que no se rechaza la hipótesis nula de independencia con una significancia del 5%, lo que significa que no se encontró evidencia estadística significativa para afirmar que exista una asociación entre el *Sexo* y la ausencia de *Método de pago*.




## Imputación de datos faltantes



### Imputación del Precio (price)

Los boxplots de la Figura \@ref(fig:figPreciocategory1) evidencian diferencias notorias entre las medianas de al menos cuatro categorías, lo que sugiere una fuerte heterogeneidad en los precios según la categoría del producto.

Las curvas de densidad de los precios por categoría, ilustradas en las Figuras \@ref(fig:figPreciocategory2) y \@ref(fig:figPreciocategory3), exhiben picos en diferentes rangos de valores, lo que sugiere variaciones significativas en la distribución del precio según la categoría del producto.


La Figura \@ref(fig:figPreciocategorycantidad) evidencia una tendencia lineal positiva entre el precio y la cantidad de productos comprados para la mayoría de las categorías, con la salvedad de `books`, en la cual no se aprecia esta correlación.



```{r figPreciocategory1,fig.cap="Distribución del precio según  categoría.", echo=FALSE}
ggplot(datos_mod4, aes(x = category, y = price, fill = category)) +
  geom_boxplot() +
  labs(title = "Distribución del Precio según Categoría",
       x = "Categoría",
       y = "Precio") +
  theme_minimal() +
  theme(legend.position = "none",          
        axis.text.x = element_text(angle = 45, hjust = 1)) 
```




```{r figPreciocategory2,fig.cap="Distribución del precio según categoría.", echo=FALSE}
# Filtramos los registros con precio no NA
datos_mod4_filtrados <- datos_mod4 %>% 
  filter(!is.na(price))

# Generamos el gráfico de densidad comparativo
ggplot(datos_mod4_filtrados, aes(x = price, fill = category)) +
  geom_density(alpha = 0.5) +
  labs(title = "Curvas de densidad comparativas de Precio por Categoría",
       x = "Precio",
       y = "Densidad") +
  theme_minimal()
```



```{r figPreciocategory3,fig.cap="Distribución del precio según categoría.", echo=FALSE}
# Filtramos los registros con precio no NA
datos_mod4_filtrados <- datos_mod4 %>% 
  filter(!is.na(price))

# Generamos gráficos de densidad separados por categoría
ggplot(datos_mod4_filtrados, aes(x = price)) +
  geom_density(fill = "steelblue", alpha = 0.5) +
  facet_wrap(~ category, scales = "free") +
  labs(title = "Curvas de densidad del Precio por Categoría",
       x = "Precio",
       y = "Densidad") +
  theme_minimal()
```




```{r figPreciocategorycantidad,fig.cap="Comparación de precio y cantidad por categoría.", echo=FALSE}
# Creamos un scatter plot para comparar price y quantity, diferenciados por category
ggplot(datos_mod4, aes(x = quantity, y = price, color = category)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~ category, scales = "free") +
  labs(title = "Comparación de Precio y Cantidad por Categoría",
       x = "Cantidad",
       y = "Precio") +
  theme_minimal()
```



La estrategia consiste en imputar los valores faltantes de la variable *Precio* utilizando la mediana calculada para cada combinación de *Categoría* y *Cantidad*. De este modo, se aprovecha la información específica de cada grupo, ya que la mediana es un estadístico robusto frente a outliers y sesgos, por tanto refleja de manera adecuada la tendencia central en cada segmento.

A continuación para cada grupo definido por *Categoría* y *Cantidad*, se reemplaza el valor faltante en *Precio* por la mediana de *Precio* dentro del grupo. Esta metodología permite obtener imputaciones consistentes con la distribución de precios en cada segmento y un posible dato faltante MAR o MNAR.

```{r imputacionPrecio, eval=TRUE, echo=FALSE}
datos_mod4_imputados_price <- datos_mod4 %>%
  group_by(category, quantity) %>%
  mutate(price = if_else(is.na(price), median(price, na.rm = TRUE), price)) %>%
  ungroup()


resumen_imputacion <- datos_mod4_imputados_price %>%
  group_by(category, quantity) %>%
  summarise(
    mediana = median(price, na.rm = TRUE),
    n_missing = sum(is.na(price)),
    total = n()
  )

print(resumen_imputacion)

missing_count <- sum(is.na(datos_mod4_imputados_price$price))
cat("Número de valores faltantes en Precio después de la imputación:", missing_count, "\n")
```

En el grupo correspondiente a la categoría `books` con `quantity` igual a 5 se observa que la mediana es `NA` y que `n_missing` es 1,029. Esto indica que, en ese grupo, todos los registros tenían el valor de *Precio* como faltante. En este grupo no fue posible realizar la imputación usando la mediana.

Una alternativa para resolver los datos faltantes que faltan consiste en imputar el grupo problemático (`books` con *Cantidad* igual a 5) utilizando la mediana del grupo similar, es decir, de `books` con *Cantidad* igual a 4. De esta manera se tendrían todos los datos faltantes de *Precio* imputados.

```{r imputacionPrecio2, eval=TRUE, echo=FALSE}
# Calcular la mediana para la categoría 'books' con quantity == 4
books_qty4_median <- datos_mod4 %>%
  filter(category == "books", quantity == 4, !is.na(price)) %>%
  summarise(median_books_qty4 = median(price, na.rm = TRUE)) %>%
  pull(median_books_qty4)

# Imputar 'price' utilizando la mediana por grupo; para books con quantity == 5,
# si no se puede calcular la mediana (es decir, todos son NA), se utiliza la mediana del grupo con quantity == 4.
datos_mod5 <- datos_mod4 %>%
  group_by(category, quantity) %>%
  mutate(
    med_group = median(price, na.rm = TRUE),
    price = if_else(
              is.na(price),
              if_else(category == "books" & quantity == 5 & is.na(med_group),
                      books_qty4_median,  # Usar mediana del grupo similar (books, quantity 4)
                      med_group),
              price)
  ) %>%
  ungroup()

# Verificar que ya no existan valores faltantes en 'price'
missing_count <- sum(is.na(datos_mod5$price))
cat("Número de valores faltantes en Precio después de la imputación:", missing_count, "\n")
```



Las curvas de densidad de *Precio* de las Figuras \@ref(fig:figPreciocategory1Imp) y \@ref(fig:figPreciocategory3Imp) tienen distribución muy similar a la  de la variable *Precio* antes de la imputación, lo que refleja una buena adecuada imputación de los datos.



```{r figPreciocategory1Imp,fig.cap="Distribución del precio según  categoría.", echo=FALSE}
ggplot(datos_mod5, aes(x = category, y = price, fill = category)) +
  geom_boxplot() +
  labs(title = "Distribución del Precio según categoría",
       x = "Categoría",
       y = "Precio") +
  theme_minimal() +
  theme(legend.position = "none",          
        axis.text.x = element_text(angle = 45, hjust = 1)) 
```




```{r figPreciocategory3Imp,fig.cap="Distribución del precio según categoría.", echo=FALSE}
# Generamos gráficos de densidad separados por categoría
ggplot(datos_mod5, aes(x = price)) +
  geom_density(fill = "steelblue", alpha = 0.5) +
  facet_wrap(~ category, scales = "free") +
  labs(title = "Curvas de densidad del Precio por categoría",
       x = "Precio",
       y = "Densidad") +
  theme_minimal()
```






### Imputación de la Edad (age)



La Figura \@ref(fig:figedaddensidad) muestra la curva de densidad de la variable *Edad*. Dado que la densidad de la *Edad* se ve aproximadamente uniforme entre 18 y 69/70 años, imputar usando la mediana (o la media) podría sesgar la distribución hacia un único valor central. Para imputar se selecciona un valor al azar entre 18 y 70 años.

```{r figedaddensidad,fig.cap="Distribución de edad y cantidad.", echo=FALSE}
# Gráfico de densidad para 'age'
 ggplot(datos_mod5, aes(x = age)) +
  geom_density(fill = "#DB735C", alpha = 0.5) +
  labs(title = "Curva de densidad de Edad", x = "Edad", y = "Densidad") +
  theme_minimal()
```

```{r imputacionedad, eval=TRUE, echo=FALSE}

# Fijar semilla para reproducibilidad
set.seed(123)

# Copiar el data frame para trabajar en la imputación de 'age'
datos_mod6 <- datos_mod5

# Imputar los valores faltantes de 'age' mediante muestreo aleatorio
datos_mod6$age[is.na(datos_mod6$age)] <- sample(
  na.omit(datos_mod5$age),                      # Valores observados de age
  sum(is.na(datos_mod5$age)),                   # Número de valores faltantes
  replace = TRUE                                # Permite repetir valores si es necesario
)

# Verificar que la imputación se realizó correctamente
missing_age <- sum(is.na(datos_mod6$age))
cat("Número de valores faltantes en  Edad después de la imputación:", missing_age, "\n")
```


```{r figedadcantidad2,fig.cap="Distribución de edad y cantidad.", echo=FALSE}
# Gráfico de densidad para 'age'
ggplot(datos_mod6, aes(x = age)) +
  geom_density(fill = "#DB735C", alpha = 0.5) +
  labs(title = "Curva de densidad de Edad", x = "Edad", y = "Densidad") +
  theme_minimal()
```

La Figura \@ref(fig:figedadcantidad2) muestra la curva de densidad de la variable *Edad*  después de imputar los datos faltantes. La distribución de antes y después se aprecian muy similares.



### Imputación de Sexo (gender), Centro Comercial (shopping_mall) y Método de pago (payment_method)

Los datos faltantes de las variables *Sexo*, *Centro comercial* y *Método de pago* son imputados usando la moda de cada una de las variables.

La Figura \@ref(fig:figimpSCCM) muestra la distribución estas variables antes y después de la imputación de los datos.
Ambas distribuciones se aprecian muy parecidas, lo que es una buena señal para continuar con el análisis.

```{r imputacionSCCM, eval=TRUE, echo=FALSE}

datos_mod7<-datos_mod6

# Función para calcular la moda
calcular_moda <- function(x) {
  # Eliminar valores NA
  x <- na.omit(x)
  # Calcular la moda (el valor que aparece con mayor frecuencia)
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Imputar la variable 'gender' (sexo) por la moda
moda_gender <- calcular_moda(datos_mod7$gender)
datos_mod7$gender[is.na(datos_mod7$gender)] <- moda_gender

# Imputar la variable 'shopping_mall' (centro comercial) por la moda
moda_mall <- calcular_moda(datos_mod7$shopping_mall)
datos_mod7$shopping_mall[is.na(datos_mod7$shopping_mall)] <- moda_mall

# Imputar la variable 'payment_method' (método de pago) por la moda
moda_payment <- calcular_moda(datos_mod7$payment_method)
datos_mod7$payment_method[is.na(datos_mod7$payment_method)] <- moda_payment

# Verificar que ya no existan valores faltantes en estas columnas
cat("Valores faltantes en 'gender':", sum(is.na(datos_mod6$gender)), "\n")
cat("Valores faltantes en 'shopping_mall':", sum(is.na(datos_mod6$shopping_mall)), "\n")
cat("Valores faltantes en 'payment_method':", sum(is.na(datos_mod6$payment_method)), "\n")

```

```{r figimpSCCM,fig.cap="Distribución de edad y cantidad.", echo=FALSE}

# Gráficos para la variable 'gender'
plot_gender_before <- ggplot(datos_mod6, aes(x = gender)) +
  geom_bar(fill = "#DB735C") +
  labs(title = "Gender - Sin Imputar", x = "Gender", y = "Conteo") +
  theme_minimal()

plot_gender_after <- ggplot(datos_mod7, aes(x = gender)) +
  geom_bar(fill = "#2A91A2") +
  labs(title = "Gender - Con Imputar", x = "Gender", y = "Conteo") +
  theme_minimal()

# Gráficos para la variable 'shopping_mall'
plot_mall_before <- ggplot(datos_mod6, aes(x = shopping_mall)) +
  geom_bar(fill = "#DB735C") +
  labs(title = "Shopping Mall - Sin Imputar", x = "Shopping Mall", y = "Conteo") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

plot_mall_after <- ggplot(datos_mod7, aes(x = shopping_mall)) +
  geom_bar(fill = "#2A91A2") +
  labs(title = "Shopping Mall - Con Imputar", x = "Shopping Mall", y = "Conteo") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Gráficos para la variable 'payment_method'
plot_payment_before <- ggplot(datos_mod6, aes(x = payment_method)) +
  geom_bar(fill = "#DB735C") +
  labs(title = "Payment Method - Sin Imputar", x = "Payment Method", y = "Conteo") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

plot_payment_after <- ggplot(datos_mod7, aes(x = payment_method)) +
  geom_bar(fill = "#2A91A2") +
  labs(title = "Payment Method - Con Imputar", x = "Payment Method", y = "Conteo") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Organizar todos los gráficos en una grilla de 2 columnas y 3 filas
grid.arrange(
  plot_gender_before, plot_gender_after,
  plot_mall_before, plot_mall_after,
  plot_payment_before, plot_payment_after,
  ncol = 2, nrow = 3
)
```
