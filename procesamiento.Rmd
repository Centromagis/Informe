# Procesamiento


```{r datos_originales2,include=FALSE}

# Importar base de datos
datos <- readxl::read_excel("datos/datos_actividad1.xlsx", sheet = "customer_shopping_data") 

```


## Errores e inconsistencias

### Errores de escritura

En la primera etapa del preprocesamiento de los datos, se procedió a la estandarización de la notación utilizada en las categorías de las variables *Sexo*, *Categoría* y *Método de pago*. Estas variables presentaban inconsistencias tipográficas al representar una misma categoría. Por ejemplo, en la variable *Sexo* se encontraron notaciones como `"female"` y `"Female"`, así como `"male"` y `"Male"`, los cuales debían ser tratados como equivalentes. De manera similar, en la variable *Categoría* se identificaron registros como `"clothing"` y `"Clothing"`, `"cosmetics"` y `"Cosmetics"`, así como `"toys"`, `"Toys"` y `"ToyS"`, todos ellos correspondientes a una misma categoría conceptual. En el caso de la variable *Método de pago*, se observaron valores como `"cash"` y `"Cash"`, además de `"debit card"` y `"Debit card"`, que remiten a una misma modalidad de pago. Estas inconsistencias fueron corregidas mediante la transformación a notación estandarizada en minúsculas.


### Inconsistencias

#### Identificadores de facturas

En una segunda etapa, se verificó la unicidad de los identificadores de facturas, considerando que, en términos generales, un número de factura no debería repetirse dentro de un mismo sistema de facturación, dado que su función principal es permitir la identificación única de cada transacción registrada, tanto para fines internos como fiscales. No obstante, es posible que un mismo identificador aparezca en múltiples filas cuando cada una representa un producto distinto incluido en la misma factura. Sin embargo, este no fue el caso en el presente conjunto de datos.

Durante la revisión de los identificadores de factura, se detectaron nueve registros duplicados, en los cuales el mismo número de factura estaba asociado a diferentes fechas y clientes. De estos duplicados, siete coincidían completamente en la información relacionada con el cliente y la transacción realizada, lo que indicó la presencia de duplicados exactos. Como resultado, se eliminaron siete de estos registros, dejando solo uno por factura. Además, se identificaron dos facturas duplicadas debido a errores en la asignación de identificadores, lo que afectó a cuatro registros. A estos registros se les asignaron nuevos identificadores únicos: `"i000000"`, `"i111111"`, `"i222222"` y `"i333333"`. Como consecuencia de este proceso, se eliminaron 7 registros, quedando un total de 99,459 transacciones para continuar con el análisis.



```{r,eval=TRUE,include=FALSE}

# Creación de tablas de variables cualitativas para revisar notación de categorías

table(datos$invoice_no)
pos1<-which(table(datos$invoice_no)!=1)
duplicadas1<-table(datos$invoice_no)[pos1]

table(datos$customer_id)
pos2<-which(table(datos$customer_id)!=1)
duplicadas2<-table(datos$customer_id)[pos2]

table(datos$gender)
table(datos$category)
table(datos$payment_method)
table(datos$shopping_mall)

# Unificación de la notación de categorías y convresión a minúsculas
datos$invoice_no     = str_to_lower(datos$invoice_no)
datos$customer_id    = str_to_lower(datos$customer_id)
datos$gender         = str_to_lower(datos$gender)
datos$category       = str_to_lower(datos$category)
datos$payment_method = str_to_lower(datos$payment_method)
datos$shopping_mall  = str_to_lower(datos$shopping_mall)

# Revisando que haya unico identificador de factura
table(datos$invoice_no)
pos1<-which(table(datos$invoice_no)!=1)
duplicadas1<-table(datos$invoice_no)[pos1]
pos1 # 9 facturas con Id repetido: i131678 i152790 i184085 i258204 i294687 i317333 i337719 i934204 i993048 


# Identificación de registros duplicados 
pos<-which(duplicated(datos)==TRUE)
datos$invoice_no[pos]  
# [1] "i317333" "i294687" "i337719" "i258204" "i152790" "i131678" "i184085"
# Las facturas i934204 i993048 no correspondn a registros duplicados

num_filas_duplicadas_1 <- sum(duplicated(datos))#7 filas duplicadas
print(paste("Registro duplicados:", num_filas_duplicadas_1))


# Eliminación  de registros duplicados
datos_sin_duplicados <- datos %>%
  distinct()

# Identificación de posición en la data de facturas con Id con error
pos3<-which(datos_sin_duplicados$invoice_no=="i934204") 
pos4<-which(datos_sin_duplicados$invoice_no=="i993048")       
      


# Eliminación de registros de facturas mal registradas
datos_sin_duplicados[c(pos3,pos4),1]<-c("i000000","i111111","i222222","i333333")

#Número de registros y variables
dim(datos_sin_duplicados)
datos_mod1<-datos_sin_duplicados

```

En una tercera etapa se analizaron posibles errores y valores atípicos en las variables cuantitativas:  Edad, precio y cantidad del producto.

#### Edad

La Figura \@ref(fig:fig-edad) evidencia que la variable *Edad* no presenta valores atípicos. Este hallazgo se corrobora con la Tabla \@ref(tab:tabla-edad), la cual muestra las estadísticas descriptivas de la variable Edad y revela que el rango de edades, de 18 a 69 años, es coherente y plausible para los identificadores de compra.


```{r fig-edad, eval=TRUE,fig.cap="Edad (años).",echo=FALSE}

datos_limpios <- datos_mod1 %>% filter(is.finite(age))

# box-plot sin rejilla ni marcas en el eje X 
ggplot(datos_limpios, aes(x = "", y = age)) +
  geom_boxplot(fill = "#DB735C") +
  labs(x = NULL, y = "Edad") +
  theme_minimal(base_size = 16) +
  theme(
    axis.title.y        = element_text(size = 16),
    axis.text.y         = element_text(size = 16),
    axis.text.x         = element_blank(),   # suprime números eje X
    axis.ticks.x        = element_blank(),   # suprime ticks eje X
    panel.grid.major    = element_blank(),   # quita toda la rejilla
    panel.grid.minor    = element_blank()
  )

```





```{r tabla-edad, eval=TRUE,echo=FALSE}



# Calcular estadísticas de edad e incluir CV
tabla_edad <- datos_mod1 %>%
  summarise(
    n     = n(),
    Min   = min(age, na.rm = TRUE),
    Q1    = quantile(age, 0.25, na.rm = TRUE),
    Q2    = quantile(age, 0.50, na.rm = TRUE),
    Q3    = quantile(age, 0.75, na.rm = TRUE),
    Max   = max(age, na.rm = TRUE),
    iqr   = IQR(age, na.rm = TRUE),
    Atm   = sum(age < (Q1 - 1.5 * iqr), na.rm = TRUE),
    AtM   = sum(age > (Q3 + 1.5 * iqr), na.rm = TRUE),
    CV    = sd(age, na.rm = TRUE) / mean(age, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # Eliminamos iqr y redondeamos CV
  select(-iqr) %>%
  mutate(
    CV = round(CV, 3)
  )

# Mostrar la tabla con kable
knitr::kable(
  tabla_edad,
  booktabs = TRUE,
  digits   = c(0, 0, 2, 2, 2, 0, 0, 0, 3),
  col.names = c(
    "n", "Min", "Q1", "Q2", "Q3", "Max",
    "Atm", "AtM", "CV"
  ),
  caption = paste(
    "Estadísticas de edad (años). Se presentan: n (número de registros);",
    "Q1 (primer cuartil); Q2 (mediana); Q3 (tercer cuartil);",
    "Min (mínimo); Max (máximo);",
    "Atm (atípicos inferiores); AtM (atípicos superiores);",
    "CV (coeficiente de variación)."
  )
)

```



#### Precio


La Figura \@ref(fig:fig-precio-todo) y la Tabla \@ref(tab:tabla-precio-todo) evidencian distribuciones prácticamente idénticas del precio unitario por categoría de producto en los distintos centros comerciales. Para profundizar en las posibles diferencias, a continuación se analiza con detalle el precio de cada categoría de producto.


```{r fig-precio-todo, eval=TRUE,fig.cap="Distribución de precios por categoría y centro comercial.", echo=FALSE}

# Datos sin NA
datos_clean <- datos%>%
   filter(!is.na(category), !is.na(shopping_mall), !is.na(price))

# Boxplot de precios unitarios por categoría y centro comercial
ggplot(datos_clean, aes(x = category, y = price, fill = category)) +
  geom_boxplot(alpha = 0.8, width = 0.6, outlier.alpha = 0.4) +
  facet_wrap(~ shopping_mall, scales = "free_y", ncol = 2) +
  labs(
    x     = "Categoría de producto",
    y     = "Precio unitario",
    title = "",
    fill  = "Categoría"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x      = element_text(angle = 45, hjust = 1, size = 9, face = "plain"),
    axis.text.y      = element_text(size = 9, face = "plain"),
    axis.title       = element_text(size = 12, face = "plain"),
    strip.text       = element_text(size = 9, face = "plain"),
    legend.position  = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

```




```{r tabla-precio-todo, eval=TRUE,echo=FALSE}


# Calcular los estadísticos por categoría y centro comercial
tabla_price_todo <- datos_clean %>%
  group_by(category, shopping_mall) %>%
  summarise(
    Min     = min(price, na.rm = TRUE),
    Q1      = quantile(price, 0.25, na.rm = TRUE),
    Mediana = median(price, na.rm = TRUE),
    Q3      = quantile(price, 0.75, na.rm = TRUE),
    Max     = max(price, na.rm = TRUE),
    CV      = sd(price, na.rm = TRUE) / mean(price, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(CV = round(CV, 3)) %>%
  arrange(category, shopping_mall)

# Mostrar con kable
kable(
  tabla_price_todo,
  booktabs = TRUE,
  digits   = c(0, 2, 2, 2, 0, 3),  # Min, Q1, Mediana, Q3, Max, CV
  col.names = c(
    "Categoría", "Centro comercial",
    "Mínimo", "Q1", "Mediana", "Q3", "Máx.", "CV"
  ),
  caption = paste(
    "Resumen del precio por categoría y centro comercial.",
    "Q1: primer cuartil; Mediana (Q2); Q3: tercer cuartil;",
    "Min: mínimo; Máx.: máximo; CV: coeficiente de variación."
  )
)

```


Para facilitar la presentación de las cifras, el precio se reescaló a  miles de unidades monetarias (price := price/1,000). Todas las imputaciones y transformaciones logarítmicas se realizaron sobre esta escala; los precios imputados resultan, por tanto, en miles. 



```{r fig-precio-categorias, eval=TRUE,fig.cap="Precio (liras turcas), en unidades de  mil, por Categoría del producto.", echo=FALSE}

# Escalamos price a 10 miles
datos_mod1 <- datos_mod1 %>%
  mutate(price = price / 1000)

ggplot(
  filter(datos_mod1, is.finite(price)),
  aes(x = category, y = price, fill = category)    # mapear fill a category
) +
  geom_boxplot(alpha = 0.8, width = 0.6, outlier.alpha = 0.4) +
  scale_fill_brewer(palette = "Set3") +            # paleta de colores
  labs(
    x    = "Categoría",
    y    = "Precio (en unidades de  mil)",
    fill = "Categoría"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    axis.title.x      = element_text(size = 12, face = "plain"),
    axis.title.y      = element_text(size = 12, face = "plain"),
    axis.text.x       = element_text(size = 9, angle = 45, hjust = 1, face = "plain"),
    axis.text.y       = element_text(size = 10, face = "plain"),
    panel.grid.major  = element_blank(),
    panel.grid.minor  = element_blank(),
    legend.position   = "right"
  )

```



```{r tabla-precio-categoria, eval=TRUE,echo=FALSE}



tabla_resumen1 <- datos_mod1 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  summarise(
    n = n(),
    `NA en price` = sum(is.na(price)),
    `Min` = min(price, na.rm = TRUE),
    `Q1` = quantile(price, 0.25, na.rm = TRUE),
    `Q2` = quantile(price, 0.5, na.rm = TRUE),
    `Q3`= quantile(price, 0.75, na.rm = TRUE),
    `Max` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atm` = sum(price < (`Q1` - 1.5 * iqr), na.rm = TRUE),
    `AtM` = sum(price > (`Q3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)


# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen1, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas), en unidades de  mil, sin 3 atípicos. En la tabla se presentan el número de registros (n), el primer cuartil (Q1), 
la mediana (Q2), el tercer cuartil (Q3), el valor mínimo (Min), 
el valor máximo (Max), así como la cantidad de atípicos inferiores (Atm)
y superiores (AtM).")




```



La Figura \@ref(fig:fig-precio-categorias) indica que, en la variable *Precio*, se detectó al menos un valor atípico en la categoría `books, food and beverage`. La Tabla \@ref(tab:tabla-precio-categoria) presenta las estadísticas de la variable *Precio* para cada categoría de productos. Se observa que en las categorías `books` y `food and beverage` el precio de un producto es significativamente superior al de los demás. Asimismo, se identificó un valor atípico entre los nueve datos faltantes (`NA`) de los productos sin categoría conocida.


Los valores atípicos de 7,575,000 y 523,000 liras turcas, correspondientes a las categorías `books` y `food and beverage`, representan precios unitarios muy altos para sus respectivas categorías. Por ello, se consideran valores inconsistentes. Estos tres datos atípicos serán tratados como datos faltantes (`NA`) en el resto del análisis. Posteriormente, se observa en la Figura \@ref(fig:fig-precio-categoria-sin-atipicos) que la variable *Precio* ya no presenta estos valores inconsistentes.


```{r tabla-precio-categoria-sin-atipicos, eval=TRUE,echo=FALSE}


# Columna de índice (posición)
datos_mod2 <- datos_mod1 %>%
  mutate(pos = row_number())

# Calcular los límites y detectar outliers por categoría para crear la tabla
tabla_outliers <- datos_mod2 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  mutate(
    q1 = quantile(price, 0.25, na.rm = TRUE),
    q3 = quantile(price, 0.75, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    lower_lim = q1 - 1.5 * iqr,
    upper_lim = q3 + 1.5 * iqr
  ) %>%
  # Filtrar los registros atípicos
  filter(price < lower_lim | price > upper_lim) %>%
  summarise(
    outlier_positions = list(pos),
    n_atipicos = n()
  )

# Extraer todas las posiciones de los outliers en un vector sencillo
all_outlier_positions <- unlist(tabla_outliers$outlier_positions)

# Reemplazar en el data frame los valores atípicos de 'price' por NA
datos_mod2$price[all_outlier_positions] <- NA

```


```{r fig-precio-categoria-sin-atipicos, eval=TRUE,fig.cap="Precio (liras turcas), en unidades de mil,  por categoría del producto sin atípicos.", echo=FALSE}


ggplot(
  filter(datos_mod2, is.finite(price)), 
  aes(x = category, y = price, fill = category)  # aquí mapeamos el fill
) +
  geom_boxplot(alpha = 0.8, width = 0.6, outlier.alpha = 0.4) +
  labs(
    x    = "Categoría",
    y    = "Precio (unidades de  mil)",
    fill = "Categoría"           # título de la leyenda
  ) +
  scale_fill_brewer(palette = "Set3") +  # o cualquier otra paleta
  theme_minimal(base_size = 16) +
  theme(
    axis.title.x      = element_text(size = 16, face = "plain"),
    axis.title.y      = element_text(size = 16, face = "plain"),
    axis.text.x       = element_text(size = 14, angle = 45, hjust = 1, face = "plain"),
    axis.text.y       = element_text(size = 14, face = "plain"),
    panel.grid.major  = element_blank(),
    panel.grid.minor  = element_blank(),
    legend.position   = "right"
  )


```


La Tabla \@ref(tab:tabla-precio-categoria-sin-atipicos2) muestra las estadísticas de la variable *Precio* excluyendo las tres inconsistencias identificadas por valores atípicos. Se ha observado que, en las categorías `clothing` y `technology`, los valores de 1 y 3 liras turcas, respectivamente, no son plausibles en centros comerciales de ropa y tecnología nueva. Por ello, dichos valores han sido clasificados como inconsistentes y, en lo sucesivo, se tratarán como datos faltantes.

Adicionalmente, se ha determinado que el valor de 7,575 liras turcas asignado a la categoría de `books` solo podría corresponder a ediciones de lujo, las cuales no están contempladas en los centros comerciales de la muestra. La Tabla \@ref(tab:tabla-precio-categoria-sin-atipicos-sin-inconsistencias) presenta las estadísticas de la variable *Precio* luego de reemplazar estas inconsistencias por `NA`. Asimismo, se evidencia que el valor de 2 liras turcas para la categoría `clothing` debe ser considerado `NA`. 

La Tabla \@ref(tab:tabla-precio-categoria-sin-atipicos-sin-inconsistencias2) expone las estadísticas del precio por categoría tras el tratamiento de las inconsistencias como datos faltantes. Se ha determinado que los siguientes rangos de precios en liras turcas son plausibles en los diez centros comerciales de la muestra:  

- `books`: entre 303 y 4,545  

- `clothing`: entre 15,004 y 120,032  

- `cosmetics`: entre 2,033 y 16,264  

- `food and Beverage`: entre 523 y 2,615  

- `shoes`: entre 60,017 y 300,085  

- `souvenir`: entre 1,173 y 5,865  

- `technology`: entre 1,050 y 5,250  

- `toys`: entre 1,792 y 14,336




```{r tabla-precio-categoria-sin-atipicos2, eval=TRUE,echo=FALSE}

tabla_resumen2 <- datos_mod2 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  summarise(
    n = n(),
    `NA en price` = sum(is.na(price)),
    `Min` = min(price, na.rm = TRUE),
    `Q1` = quantile(price, 0.25, na.rm = TRUE),
    `Q2` = quantile(price, 0.5, na.rm = TRUE),
    `Q3`= quantile(price, 0.75, na.rm = TRUE),
    `Max` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atm` = sum(price < (`Q1` - 1.5 * iqr), na.rm = TRUE),
    `AtM` = sum(price > (`Q3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)


# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen2, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas), en unidades de mil, sin 3 atípicos. En la tabla se presentan el número de registros (n), el primer cuartil (Q1), 
la mediana (Q2), el tercer cuartil (Q3), el valor mínimo (Min), 
el valor máximo (Max), así como la cantidad de atípicos inferiores (Atm)
y superiores (AtM).")

```


```{r tabla-precio-categoria-sin-atipicos-sin-inconsistencias, eval=TRUE,echo=FALSE}

# Reemplazar valores específicos según la categoría:
datos_mod3 <- datos_mod2 %>%
  filter(!is.na(category)) %>%
  mutate(price = case_when(
    category == "clothing" & price == 1 ~ NA,      # Reemplaza 1 por NA en 'clothing'
    category == "technology" & price == 3 ~ NA,     # Reemplaza 3 por NA en 'technology'
    TRUE ~ price
  ))

tabla_resumen3 <- datos_mod3 %>%
  group_by(category) %>%
  summarise(
    n = n(),
    `NA en price` = sum(is.na(price)),
    `Min` = min(price, na.rm = TRUE),
    `Q1` = quantile(price, 0.25, na.rm = TRUE),
    `Q2`    = quantile(price, 0.5, na.rm = TRUE),
    `Q3`  = quantile(price, 0.75, na.rm = TRUE),
    `Max` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atm` = sum(price < (`Q1` - 1.5 * iqr), na.rm = TRUE),
    `AtM` = sum(price > (`Q3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)



# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen3, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas), en unidades de  mil, sin  inconsistencias de clothing y technology. En la tabla se presentan el número de registros (n), el primer cuartil (Q1), 
la mediana (Q2), el tercer cuartil (Q3), el valor mínimo (Min), 
el valor máximo (Max), así como la cantidad de atípicos inferiores (Atm)
y superiores (AtM).") 

```


```{r tabla-precio-categoria-sin-atipicos-sin-inconsistencias2, eval=TRUE,echo=FALSE}

# Reemplazar valores específicos según la categoría:
datos_mod4 <- datos_mod3 %>%
  mutate(price = case_when(
    category == "clothing" & price == 2 ~ NA,      # Reemplaza 1 por NA en 'clothing'
    category == "books" & price == 7575 ~ NA,      # Reemplaza 1 por NA en 'clothing'
    TRUE ~ price
  ))

tabla_resumen4 <- datos_mod4 %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
 summarise(
    n = n(),
    `NA en price` = sum(is.na(price)),
    `Min` = min(price, na.rm = TRUE),
    `Q1` = quantile(price, 0.25, na.rm = TRUE),
    `Q2`    = quantile(price, 0.5, na.rm = TRUE),
    `Q3`  = quantile(price, 0.75, na.rm = TRUE),
    `Max` = max(price, na.rm = TRUE),
    iqr = IQR(price, na.rm = TRUE),
    `Atm` = sum(price < (`Q1` - 1.5 * iqr), na.rm = TRUE),
    `AtM` = sum(price > (`Q3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)




# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen4, 
             booktabs = TRUE,
             caption = "Estadísticas del Precio (liras turcas), en unidades de mil, sin  inconsistencias de clothing y technology. En la tabla se presentan el número de registros (n), el primer cuartil (Q1), 
la mediana (Q2), el tercer cuartil (Q3), el valor mínimo (Min), 
el valor máximo (Max), así como la cantidad de atípicos inferiores (Atm)
y superiores (AtM).") 

```


#### Cantidad de productos

Por último, la Tabla \@ref(tab:tabla-cantidad-categoria) presenta las estadísticas descriptivas del número de artículos por categoría. Se observa que la cantidad de ítems por transacción oscila entre 1 y 5, sin valores atípicos ni inconsistencias que requieran corrección.


```{r tabla-cantidad-categoria, eval=TRUE,echo=FALSE}

tabla_resumen_cantidad <- datos_mod4  %>%
  filter(!is.na(category)) %>%
  group_by(category) %>%
  summarise(
    n = n(),
    `NA en price` = sum(is.na(quantity)),
     `min` = min(quantity, na.rm = TRUE),
    `Q1` = quantile(quantity, 0.25, na.rm = TRUE),
    `Q2`    = quantile(quantity, 0.5, na.rm = TRUE),
    `Q3`  = quantile(quantity, 0.75, na.rm = TRUE),
    `Max` = max(quantity, na.rm = TRUE),
    iqr = IQR(quantity, na.rm = TRUE),
    `Atm` = sum(quantity < (`Q1` - 1.5 * iqr), na.rm = TRUE),
    `AtM` = sum(quantity > (`Q3` + 1.5 * iqr), na.rm = TRUE)
  ) %>%
  select(-iqr)



# Mostrar la tabla con un caption y label
knitr::kable(tabla_resumen_cantidad, 
             booktabs = TRUE,
             caption = "Estadísticas de Cantidad de productos. En la tabla se presentan el número de registros (n), el primer cuartil (Q1), 
la mediana (Q2), el tercer cuartil (Q3), el valor mínimo (Min), 
el valor máximo (Max), así como la cantidad de atípicos inferiores (Atm)
y superiores (AtM).") 

```

---

## Análisis de datos atípicos

Según los hallazgos, los valores atípicos detectados en la variable *Precio* —evaluada por categoría— corresponden a inconsistencias que se han recodificado como valores faltantes (`NA`), los que posteriormente serán imputados. Por su parte, las variables *Edad* y *Cantidad* de artículos no presentan outliers. En consecuencia, de cara al análisis posterior se asume que las variables cuantitativas están libres de datos atípicos.

---

## Identificación de datos faltantes

La Figura \@ref(fig:fig-datos-faltantes) muestra que las variables *Precio*, *Sexo* y *Edad* presentan el mayor porcentaje de datos faltantes, seguidas de *Centro comercial*  y *Método de pago*. Asimismo, evidencia que el porcentaje más alto de datos faltantes no supera el 1.06%.


Adicionalmente, la Figura \@ref(fig:fig-datos-faltantes) indica que 99,369 de los registros no presenta datos faltantes (combinación 1), mientras que el 24 de registros presenta valores faltantes en *Precio* (combinación 2). Además, se identificaron el 19 de registros con datos faltantes en *Edad* (combinación 3) y otro 19 en *Sexo* (combinación 4). De igual forma, se detectó que 11 de los registros tienen datos faltantes en *Centros comerciales* (combinación 5) y 8  en *Método de pago* (combinación 6). La  Figura \@ref(fig:fig-datos-faltantes) se presenta un resumen de las variables ordenadas según el número de datos faltantes.


 
```{r fig-datos-faltantes, eval=TRUE,fig.cap="Porcentaje de datos faltantes por variables y combinaciones de faltantes por variables.", echo=FALSE,fig.width=10, fig.height=8}


# Seleccionamos solo las primeras 10 variables
datos_mod4 <- datos_mod4[, 1:10]

# Ajuste de márgenes: inferior, izquierda, superior y derecha
par(mar = c(6, 4, 2, 2) + 0.1)

# Gráfico de patrones de missing con números
VIM::aggr(
  datos_mod4,
  col         = c("#DB735C", "#2A91A2"),  # colores: presente / faltante
  numbers     = TRUE,                     # muestra el número de casos
  prop        = FALSE,                    # FALSE = muestra conteos, TRUE = proporciones
  cex.numbers = 0.8,                      # tamaño de los números
  sortVars    = TRUE,                     # ordena variables por % de missing
  labels      = names(datos_mod4),        # etiquetas para el eje X
  cex.axis    = 0.7,                      # tamaño del texto en el eje X
  las         = 2,                        # rota las etiquetas del eje X (vertical)
  gap         = 3,                        # espacio entre barras
  combined    = FALSE,                    # muestra el barplot separado para cada variable
  ylab        = c("Proporción de datos",  # etiquetas del eje Y
                  "Datos faltantes")
)


```


Para evaluar formalmente si las ausencias se distribuyen de manera completamente aleatoria (MCAR), se aplicó la prueba de Little (implementada en `naniar::mcar_test()`) a las variables cuantitativas (*Edad*, *Cantidad*, *Precio*), cuya hipótesis nula establece que los datos faltantes se distribuyen de forma aleatoria. Dado el gran tamaño de la base de datos (99,450 registros), se estableció un nivel de significancia muy estricto (0.001).

El $valor-p$ obtenido fue igual a  0.207492, lo que lleva a  no rechazar la hipótesis nula con una significancia del 1%. Esto indica que no existe evidencia suficiente para descartar que los datos faltantes sean completamente aleatorios.


```{r test-MCAR, eval=TRUE, echo=FALSE}

# Seleccionar únicamente las variables cuantitativas pertinentes para el test
datos_numeric <- datos_mod4 %>% 
  select(age, quantity, price)

# Aplicar el test de Little para evaluar si los datos faltantes son MCAR
resultado_mcar <- naniar::mcar_test(datos_numeric)

# Extraer el valor p del resultado del test
p_val <- resultado_mcar$p.value
p_val

```


```{r figNormMCAR, eval=TRUE, fig.cap=" Q-Q de age, de quantity, de price. Además, densidad de age, de quantity, de price", echo=FALSE}

datos_limpios <- datos_numeric %>% 
  filter(if_all(c(age, quantity, price), is.finite))    # descarta NA/Inf

# Q‑Q plots
qq_age      <- ggplot(datos_limpios, aes(sample = age))      +
               stat_qq() + stat_qq_line(colour = "red") +
               ggtitle("Age")

qq_quantity <- ggplot(datos_limpios, aes(sample = quantity)) +
               stat_qq() + stat_qq_line(colour = "red") +
               ggtitle("Quantity")

qq_price    <- ggplot(datos_limpios, aes(sample = price))    +
               stat_qq() + stat_qq_line(colour = "red") +
               ggtitle("Price")

#  Densidades 
density_age      <- ggplot(datos_limpios, aes(x = age))      +
                    geom_density(fill = "blue", alpha = .3)  +
                    ggtitle("")

density_quantity <- ggplot(datos_limpios, aes(x = quantity)) +
                    geom_density(fill = "blue", alpha = .3)  +
                    ggtitle("")

density_price    <- ggplot(datos_limpios, aes(x = price))    +
                    geom_density(fill = "blue", alpha = .3)  +
                    ggtitle("")


grid.arrange(
  qq_age, qq_quantity, qq_price,
  density_age, density_quantity, density_price,
  ncol = 3
)

```

Según la Figura \@ref(fig:figNormMCAR), las variables cuantitativas no cumplen el supuesto de la normalidad  debido principalmente a la marcada discrecionalidad de *Cantidad* y a la fuerte asimetría observada en *Precio*. Este incumplimiento de los supuestos necesarios pone en entredicho la fiabilidad del test MCAR (basado en el método de Little), que indicó que los datos  se distribuyen de forma completamente aleatoria.

El objetivo del siguiente análisis es evaluar el mecanismo de ausencia de datos en la variable *Precio*. Para ello, se creó una variable indicadora que refleja si el dato de *Precio* está ausente (1) o presente (0). Posteriormente, se ajustó un modelo de regresión logística utilizando como predictores las variables *Edad*, *Cantidad*, *Sexo*, *Método de pago*  y *Categoría*. 

El modelo permite determinar si la probabilidad de tener un dato faltante en *Precio* está asociada a alguna de estas variables, lo que ayudaría a descartar la hipótesis de que los datos faltantes se distribuyen de forma completamente aleatoria (MCAR).

```{r glmMCAR_Precio, eval=TRUE, echo=FALSE}

datos_mod4 <- datos_mod4 %>%
  mutate(miss_price = ifelse(is.na(price), 1, 0))

modelo_missing <- glm(miss_price ~ age + quantity + factor(gender) + factor(category) + factor(payment_method), 
                      data = datos_mod4, family = binomial)
summary(modelo_missing)

```

De acuerdo con el modelo de regresión logística, la variable *Cantidad* se asocia de forma significativa con la probabilidad de ausencia de *Precio* ($valor-p = 0.0238$) al nivel de significancia del 3%, mientras que *Edad*, *Método de pago*, *Categoría* y *Sexo* no resultan predictores relevantes de dicha ausencia. Este hallazgo descarta la hipótesis de “datos faltantes completamente al azar” (*MCAR*), aunque el gran tamaño muestral (> 99 000 observaciones) incrementa la potencia estadística y aconseja adoptar un umbral de significancia más estricto. Para minimizar posibles sesgos, la imputación de *Precio* se realizará mediante un enfoque estratificado que contemple tanto los valores de *Cantidad* como la *Categoría* del producto.


El objetivo del siguiente análisis es evaluar el mecanismo de ausencia de datos en la variable *Edad*. Para ello, se creó una variable indicadora que toma valor 1 cuando *Edad* está ausente y 0 cuando está presente. A continuación, se ajustó un modelo de regresión logística utilizando como predictores *Precio*, *Cantidad*, *Sexo*, *Método de pago* y *Categoría*.




```{r glmMCAR_Edad, eval=TRUE, echo=FALSE}

datos_mod4 <- datos_mod4 %>%
  mutate(miss_age = ifelse(is.na(age), 1, 0))

modelo_missing <- glm(miss_age ~ price + quantity + factor(gender) + factor(category) + factor(payment_method), 
                      data = datos_mod4, family = binomial)
summary(modelo_missing)

```


El modelo no evidencia ninguna asociación estadísticamente significativa entre la ausencia de *Edad* y las variables consideradas; el valor mínimo de $valor\text{-}p$ fue 0.475. Por tanto, al nivel de significancia del 5 %, no hay evidencia de que la falta de *Edad* dependa de estos predictores, lo que respalda la hipótesis de ausencia completamente al azar (MCAR) para esta variable.


En la tabla de contingencia siguiente que relaciona la presencia y ausencia de datos en *Método de pago* con las distintas categorías de productos, se observa que casi todos los registros se concentran en la fila 0 (datos presentes), mientras que la fila 1 (datos faltantes) muestra recuentos extremadamente bajos. Al aplicar el test test Fisher's Exact, se obtuvo un $valor-p$ de 0.2013, lo que lleva a no rechazar la hipótesis nula de independencia con una significancia del 5%. En otras palabras, no se encontró evidencia estadística suficiente para concluir que exista una asociación significativa entre la categoría del producto y la presencia de datos faltantes en *Método de pago*.

```{r tablacontingenciaMetodopagomisscategoria, eval=TRUE, echo=FALSE}

# Crear una variable indicadora para missing en payment_method
datos_mod4 <- datos_mod4 %>% 
  mutate(miss_payment = ifelse(is.na(payment_method), 1, 0))

# Tabla de contingencia entre la ausencia en payment_method y category
tabla_contingencia <- table(datos_mod4$miss_payment, datos_mod4$category)
print(tabla_contingencia)

# Prueba de Fisher
fisher_test <- fisher.test(tabla_contingencia, workspace = 2e8)
fisher_test

```

En la tabla de contingencia siguiente que relaciona la ausencia de *Método de pago* con *Sexo*, se observa que la gran mayoría de los registros tienen datos presentes (fila 0), con 59,461 registros para 'female' y 39,962 para 'male', mientras que en la fila de datos faltantes (fila 1) apenas hay 6 registros para 'female' y 2 para 'male'.

Al aplicar el test Fisher's Exact, se obtuvo un $valor-p$ de 0.488. Este resultado indica que no se rechaza la hipótesis nula de independencia con una significancia del 5%, lo que significa que no se encontró evidencia estadística significativa para afirmar que exista una asociación entre el *Sexo* y la ausencia de *Método de pago*.


```{r tablacontingenciaMetodopagomissGender, eval=TRUE, echo=FALSE}

# Tabla de contingencia entre la ausencia en payment_method y gender
tabla_contingencia <- table(datos_mod4$miss_payment, datos_mod4$gender)
print(tabla_contingencia)

# Prueba de chi-cuadrado
fisher_test <- fisher.test(tabla_contingencia, workspace = 2e8)
fisher_test

```



## Imputación de datos faltantes



### Imputación del Precio (price)




De acuerdo con la Figura \@ref(fig:figinfprecio) y los resultados de la Tabla \@ref(tab:tabla-resultadomalls0) la distribución del precio por categoría y centro comercial es muy similar.  Teniendo  en cuenta los resultados de la sección anterior, la estrategia consiste en imputar los valores faltantes de la variable *Precio* utilizando  la información de  la *Cantidad* y *Categoria*. 


```{r figinfprecio,fig.cap="Distribución del precio  (unidades de 10 mil) por producto y centro comercial.", echo=FALSE}


ggplot(datos_mod4,
       aes(x = category, y = price, fill = category)) +
  geom_boxplot(alpha = .8, width = .6, outlier.alpha = .3) +
  # Sólo ncol; facet_wrap organizará las filas necesarias
  facet_wrap(~ shopping_mall, ncol = 2, scales = "free_y") +
  labs(
    x    = "Tipo de producto",
    y    = "Precio (en unidades de  mil)",
    fill = "Categoría"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x      = element_text(size = 9, angle = 45, hjust = 1),
    axis.title.x     = element_text(size = 10, face = "plain"),
    axis.title.y     = element_text(size = 10, face = "plain"),
    strip.text       = element_text(size = 8, face = "plain"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

```




```{r tabla-resultadomalls0, eval=TRUE,echo=FALSE}

# Calcular los estadísticos por categoría y centro comercial
tabla_price_todo2<- datos_mod4 %>%
  group_by(category, shopping_mall) %>%
  summarise(
    Min     = min(price, na.rm = TRUE),
    Q1      = quantile(price, 0.25, na.rm = TRUE),
    Mediana = median(price, na.rm = TRUE),
    Q3      = quantile(price, 0.75, na.rm = TRUE),
    Max     = max(price, na.rm = TRUE),
    CV      = sd(price, na.rm = TRUE) / mean(price, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(CV = round(CV, 3)) %>%
  arrange(category, shopping_mall)

# Mostrar con kable
kable(
  tabla_price_todo2,
  booktabs = TRUE,
  digits   = c(0, 2, 2, 2, 0, 3),  # Min, Q1, Mediana, Q3, Max, CV
  col.names = c(
    "Categoría", "Centro comercial",
    "Mínimo", "Q1", "Mediana", "Q3", "Máx.", "CV"
  ),
  caption = paste(
    "Resumen del precio por categoría y centro comercial.",
    "Q1: primer cuartil; Mediana (Q2); Q3: tercer cuartil;",
    "Min: mínimo; Máx.: máximo; CV: coeficiente de variación."
  )
)


```




Para imputar los datos faltantes del precio se transformó el precio a escala logarítmica y se imputó mediante predictive mean matching con `mice`, empleando la categoría del producto y cantidad (1 – 5 codificada como factor ordinal) como predictores fijos. Para cada precio ausente el algoritmo seleccionó al azar uno de los tres valores observados más parecidos dentro de la misma categoría (matchgroup), y la opción `bounded` garantizó que el imputado quedara dentro del rango mínimo–máximo observado de ese grupo. Se generaron 15 conjuntos imputados con 10 iteraciones cada uno, suficientes para alcanzar la convergencia dado que solo el precio presentaba faltantes. Los precios imputados se retransformaron con `exp()` y se verificó gráficamente que la distribución por categoría se mantiene sin valores extremos artificiales.


```{r imputacionPrecio2, eval=TRUE, echo=FALSE,warning=FALSE}



# Data frame para la imputación
datos_imp <- datos_mod4 %>% 
  mutate(
    log_price = log(price),                       # objetivo
    quantity  = factor(quantity, ordered = TRUE)  # 1–5 como factor ordinal
  ) %>% 
  select(category, quantity, log_price) %>%       # sin otras columnas
  mutate(across(where(is.character), as.factor))  # category → factor


# Matriz de predictores 
predM <- quickpred(
  datos_imp,
  mincor  = 0,                                    # no descartar por baja correlación
  include = c("category", "quantity")             # forzar ambos
)


# Definir métodos
meth <- make.method(datos_imp);  meth[] <- ""
meth["log_price"] <- "pmm"


# Ejecutar mice 
set.seed(2025)
imp <- mice(
  datos_imp,
  method          = meth,
  predictorMatrix = predM,
  m               = 15,
  maxit           = 10,
  pmm.k           = 3,
  pmmtype         = "bounded",
  matchgroup      = datos_imp$category,
  remove.constant = TRUE,
  remove.collinear= TRUE,
  ridge           = 1e-4,
  printFlag       = FALSE  
)


# Recuperar las bases completas 
datos_imput_long <- complete(imp, "long") %>% 
  mutate(price = exp(log_price)) %>% 
  select(-log_price, -.imp, -.id)




datos_mod5 <- cbind(datos_mod4[,-c(5,6,7)],datos_imput_long)

```


En las Figuras \@ref(fig:figPreciocategory2) y \@ref(fig:figPreciocategoryImp2)  comparativas de densidades, la gráfica original (antes de imputar) muestra picos de menor altura; tras la imputación, los picos se elevan pero permanecen exactamente en las mismas posiciones de precio, señal de que el algoritmo bounded PMM copió valores observados sin introducir nuevos niveles. Así, la imputación complementa las frecuencias faltantes respetando la distribución de cada categoría.



```{r figPreciocategory2,fig.cap="Distribución del precio (se muestran en miles) según  categoría antes de la imputación.", echo=FALSE}

# Filtrar registros con precio válido
datos_mod4_filtrados <- datos_mod4 %>% 
  filter(!is.na(price))

# Gráfico de densidades sin cuadrícula
ggplot(datos_mod4_filtrados, aes(x = price)) +
  geom_density(fill = "steelblue", alpha = 0.5) +
  facet_wrap(~ category, scales = "free", nrow = 4, ncol = 2) +
  labs(x = "Precio (unidad de mil)", y = "Densidad") +
  theme_minimal(base_size = 12) +
  theme(
    strip.text        = element_text(size = 12),   # etiquetas de facetas
    axis.text.x       = element_text(size = 9),
    axis.text.y       = element_text(size = 9),
    axis.title.x      = element_text(size = 16),
    axis.title.y      = element_text(size = 16),
    panel.grid.major  = element_blank(),           # ← elimina cuadrícula principal
    panel.grid.minor  = element_blank()            # ← elimina cuadrícula menor
  )


```


```{r figPreciocategoryImp2,fig.cap="Distribución del precio (se muestran en miles) según  categoría después de la imputación.", echo=FALSE}

ggplot(datos_mod5, aes(x = price)) +
  geom_density(fill = "steelblue", alpha = 0.5) +
  facet_wrap(~ category, scales = "free", nrow = 4, ncol = 2) +
  labs(x = "Precio (en unidad de mil)", y = "Densidad") +
  theme_minimal(base_size = 12) +
  theme(
    strip.text        = element_text(size = 12),   # etiquetas de facetas
    axis.text.x       = element_text(size = 9),
    axis.text.y       = element_text(size = 9),
    axis.title.x      = element_text(size = 16),
    axis.title.y      = element_text(size = 16),
    panel.grid.major  = element_blank(),           # ← quita la cuadrícula
    panel.grid.minor  = element_blank()
  )


```


Los boxplots de las Figuras \@ref(fig:figPreciocategory1) y \@ref(fig:figPreciocategoryImp1)  muestran que la imputación multiplicó el número de observaciones en cada categoría sin introducir valores fuera de los límites reales ni distorsionar las posiciones de la mediana. Las cajas son un poco más anchas, señal de que ahora se refleja mejor la variabilidad subyacente, pero la jerarquía de precios entre categorías (shoes ≫ clothing ≫ books, etc.) permanece intacta. Esto confirma que el método bounded PMM con donantes dentro de la misma categoría preservó la estructura original de los datos mientras completaba los valores faltantes.

```{r figPreciocategory1,fig.cap="Distribución del precio (se muestran en miles) según  categoría antes de la imputación.", echo=FALSE}

ggplot(filter(datos_mod4, is.finite(price)),
       aes(category, price, fill = category)) +
  geom_boxplot() +
  labs(x = "Categoría", y = "Precio (unidad de mil)") +
  theme_minimal(base_size = 16) +
  theme(
    legend.position   = "none",
    axis.text.x       = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y       = element_text(size = 14),
    axis.title.x      = element_text(size = 16),
    axis.title.y      = element_text(size = 16),
    axis.title        = element_text(size = 16),
    panel.grid.major  = element_blank(),   # ⟵ elimina la cuadrícula principal
    panel.grid.minor  = element_blank()    # ⟵ elimina la cuadrícula menor
  )


```


```{r figPreciocategoryImp1,fig.cap="Distribución del precio (se muestran en miles) según  categoría después de la imputación.", echo=FALSE}

ggplot(datos_mod5, aes(x = category, y = price, fill = category)) +
  geom_boxplot() +
  labs(x = "Categoría", y = "Precio (unidad de mil)") +
  theme_minimal(base_size = 16) +
  theme(
    legend.position   = "none",
    axis.text.x       = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y       = element_text(size = 14),
    axis.title.x      = element_text(size = 16),
    axis.title.y      = element_text(size = 16),
    panel.grid.major  = element_blank(),   # ← quita rejilla principal
    panel.grid.minor  = element_blank()    # ← quita rejilla menor
  )


```








### Imputación de la Edad (age)

La variable Edad presenta una distribución prácticamente uniforme entre los 18 y los 69–70 años; en otras palabras, cualquier valor dentro de ese intervalo es casi igual de probable. Utilizar la media o la mediana como valor único de reemplazo concentraría todos los casos faltantes en el centro y generaría un pico artificial que no existe en los datos reales. Para evitar ese sesgo se optó por una imputación aleatoria simple: cada observación con `NA` recibe un valor extraído al azar, con probabilidad constante, dentro del rango 18–70 años. 

La Figura \@ref(fig:figedaddensidad)  compara las densidades de Edad antes y después de la imputación. Las dos curvas prácticamente se superponen, lo que confirma que el procedimiento preserva la forma original de la distribución —no introduce picos espurios ni distorsiona la frecuencia relativa de los distintos tramos de edad— y, por tanto, mantiene la representatividad de la muestra para análisis posteriores.


```{r imputacionedad, eval=TRUE, echo=FALSE}

# Fijar semilla para reproducibilidad
set.seed(123)

# Copiar el data frame para trabajar en la imputación de 'age'
datos_mod6 <- datos_mod5

# Imputar los valores faltantes de 'age' mediante muestreo aleatorio
datos_mod6$age[is.na(datos_mod6$age)] <- sample(
  na.omit(datos_mod5$age),                      # Valores observados de age
  sum(is.na(datos_mod5$age)),                   # Número de valores faltantes
  replace = TRUE                                # Permite repetir valores si es necesario
)

```


```{r figedaddensidad,fig.cap="Distribución de edad antes y después de la imputación.", echo=FALSE}

# Combinar ambas bases con un indicador
df_age <- bind_rows(
  datos_mod5 %>% mutate(grupo = "Sin imputar"),
  datos_mod6 %>% mutate(grupo = "Con imputar")
)

ggplot(df_age, aes(x = age, colour = grupo)) +
  geom_density(fill = NA, size = 1.1) +                     # solo línea
  scale_colour_manual(values = c("#DB735C", "#2A91A2"),
                      name   = "Estado",
                      labels = c("Con imputar", "Sin imputar")) +
  labs(x = "Edad (años)", y = "Densidad") +
  theme_minimal(base_size = 16) +
  theme(
    plot.title      = element_text(size = 14, face = "bold"),
    axis.title.x    = element_text(size = 16),
    axis.title.y    = element_text(size = 16),
    axis.text       = element_text(size = 14),
    legend.title    = element_text(size = 14),
    legend.text     = element_text(size = 14),
    panel.grid.major = element_blank(),   # ← quita línea mayor
    panel.grid.minor = element_blank()    # ← quita línea menor
  )


```


### Imputación de Sexo (gender), Centro Comercial (shopping_mall) y Método de pago (payment_method)

Los datos faltantes de las variables *Sexo*, *Centro comercial* y *Método de pago* son imputados usando la moda de cada una de las variables.

La Figura \@ref(fig:figimpSCCM) muestra la distribución estas variables antes y después de la imputación de los datos. Ambas distribuciones se aprecian muy parecidas, lo que es una buena señal para continuar con el análisis.


```{r imputacionSCCM, eval=TRUE, echo=FALSE}

datos_mod7<-datos_mod6

# Función para calcular la moda
calcular_moda <- function(x) {
  # Eliminar valores NA
  x <- na.omit(x)
  # Calcular la moda (el valor que aparece con mayor frecuencia)
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Imputar la variable 'gender' (sexo) por la moda
moda_gender <- calcular_moda(datos_mod7$gender)
datos_mod7$gender[is.na(datos_mod7$gender)] <- moda_gender

# Imputar la variable 'shopping_mall' (centro comercial) por la moda
moda_mall <- calcular_moda(datos_mod7$shopping_mall)
datos_mod7$shopping_mall[is.na(datos_mod7$shopping_mall)] <- moda_mall

# Imputar la variable 'payment_method' (método de pago) por la moda
moda_payment <- calcular_moda(datos_mod7$payment_method)
datos_mod7$payment_method[is.na(datos_mod7$payment_method)] <- moda_payment

```


```{r figimpSCCM,fig.cap="Distribución de Sexo, Centro comercial y Método de pago.", echo=FALSE}

# función sin cuadrícula 
plot_pct_h <- function(data, var, titulo, fill) {
  eps <- 0.001
  
  df <- data %>% 
    mutate({{ var }} := fct_explicit_na({{ var }}, na_level = "NA")) %>% 
    count({{ var }}) %>% 
    mutate(
      prop      = n / sum(n),
      prop_plot = if_else(prop < eps, eps, prop),
      label     = if_else(prop < eps, "<0.1 %", percent(prop, accuracy = 1))
    )
  
  ggplot(df, aes(prop_plot, fct_reorder(as.character({{ var }}), prop))) +
    geom_col(fill = fill) +
    geom_text(aes(label = label), hjust = -0.08, size = 3) +
    scale_x_continuous(
      labels = percent_format(accuracy = 1),
      limits = c(0, max(df$prop_plot) * 1.12),
      expand = expansion(mult = c(0, .02))
    ) +
    labs(title = titulo,
         x = "Porcentaje",
         y = str_replace_all(deparse(substitute(var)), "_", " ")) +
    theme_minimal() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )
}

# Cada gráfico
plot_gender_before <- plot_pct_h(datos_mod6, gender,         "Sin imputar", "#DB735C")
plot_gender_after  <- plot_pct_h(datos_mod7, gender,         "Con imputar", "#2A91A2")
plot_mall_before   <- plot_pct_h(datos_mod6, shopping_mall,  "Sin imputar", "#DB735C")
plot_mall_after    <- plot_pct_h(datos_mod7, shopping_mall,  "Con imputar", "#2A91A2")
plot_pay_before    <- plot_pct_h(datos_mod6, payment_method, "Sin imputar", "#DB735C")
plot_pay_after     <- plot_pct_h(datos_mod7, payment_method, "Con imputar", "#2A91A2")

# Todos los gráficos
grid.arrange(
  plot_gender_before, plot_gender_after,
  plot_mall_before,   plot_mall_after,
  plot_pay_before,    plot_pay_after,
  ncol = 2, nrow = 3
)

```



